<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Portal - Puzzle Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 14px; height: 14px; border: 2px solid #00ff00;
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
        }
        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: white; background: rgba(0,0,0,0.8); padding: 15px;
            pointer-events: none; border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="instructions">
        <b>Portal Puzzle: Level 1</b><br>
        1. Find the Red Plate on the floor.<br>
        2. Place a cube on it to open the Door.<br>
        WASD: Move | SPACE: Jump | E: Grab/Throw
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration & State ---
        let heldBox = null;
        const holdDistance = 4;
        let lastGrabTime = 0; 
        const boxes = [];
        const walls = [];
        const keys = {};
        
        let velocityY = 0;
        let velocityXZ = new THREE.Vector3();
        const gravity = -0.012; 
        const eyeHeight = 1.6; 
        let canTeleportPlayer = true;
        let doorOpen = false;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
        scene.add(light);

        const controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener('click', () => controls.lock());

        // --- 1. Textures ---
        const loader = new THREE.TextureLoader();
        const wallTex = loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
        wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
        wallTex.repeat.set(4, 2);
        
        const surfaceTex = loader.load('https://threejs.org/examples/textures/grid.png');
        surfaceTex.wrapS = surfaceTex.wrapT = THREE.RepeatWrapping;
        surfaceTex.repeat.set(20, 20);

        const wallMat = new THREE.MeshPhongMaterial({ map: wallTex });
        const surfaceMat = new THREE.MeshPhongMaterial({ map: surfaceTex });

        // --- 2. Room & Puzzle Construction ---
        const createWall = (w, h, d, x, y, z) => {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
            m.position.set(x, y, z);
            scene.add(m);
            walls.push(m);
            return m;
        };

        // Boundaries
        createWall(60, 100, 5, 0, 50, -32.5); 
        createWall(60, 100, 5, 0, 50, 32.5);  
        createWall(5, 100, 60, 32.5, 50, 0);  
        createWall(5, 100, 60, -32.5, 50, 0);  

        const surfaces = [...walls];
        const floor = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), surfaceMat);
        floor.position.set(0, -1, 0); 
        scene.add(floor);
        surfaces.push(floor);

        const ceiling = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), surfaceMat);
        ceiling.position.set(0, 51, 0); 
        scene.add(ceiling);
        surfaces.push(ceiling);

        // --- Puzzle Elements ---
        const door = createWall(20, 15, 2, 0, 7.5, 10); // The Door
        door.material = new THREE.MeshPhongMaterial({ color: 0x555555 });

        const plateGeo = new THREE.BoxGeometry(4, 0.2, 4);
        const plateMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const plate = new THREE.Mesh(plateGeo, plateMat);
        plate.position.set(15, 0.1, -15);
        scene.add(plate);

        // --- 3. Boxes ---
        const boxGeo = new THREE.BoxGeometry(2, 2, 2);
        const boxMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
        for(let i = 0; i < 3; i++) {
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.set(Math.random() * 10 - 20, 5, Math.random() * 10 - 20);
            box.velocity = new THREE.Vector3(0, 0, 0);
            box.canTeleport = true; 
            scene.add(box);
            boxes.push(box);
        }

        // --- 4. Portals ---
        const portalGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
        const bluePortal = new THREE.Mesh(portalGeo, new THREE.MeshBasicMaterial({ color: 0x00ccff }));
        const orangePortal = new THREE.Mesh(portalGeo, new THREE.MeshBasicMaterial({ color: 0xff9900 }));
        bluePortal.facing = new THREE.Vector3();
        orangePortal.facing = new THREE.Vector3();
        bluePortal.visible = orangePortal.visible = false;
        scene.add(bluePortal, orangePortal);

        // --- 5. Inputs ---
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('keydown', (e) => {
            const currentTime = performance.now();
            if (e.code === 'KeyE' && currentTime - lastGrabTime > 250) {
                if (heldBox) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    heldBox.velocity.copy(dir.multiplyScalar(0.7));
                    heldBox = null;
                } else {
                    let closest = null;
                    let minDist = holdDistance;
                    boxes.forEach(box => {
                        const d = camera.position.distanceTo(box.position);
                        if (d < minDist) { minDist = d; closest = box; }
                    });
                    heldBox = closest;
                }
                lastGrabTime = currentTime;
            }
        });

        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(surfaces);
            if (hits.length > 0) {
                const p = (e.button === 0) ? bluePortal : orangePortal;
                const hit = hits[0];
                p.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.1));
                if (Math.abs(hit.face.normal.y) > 0.5) {
                    p.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), hit.face.normal);
                } else {
                    p.lookAt(hit.point.clone().add(hit.face.normal));
                    p.rotateX(Math.PI/2);
                }
                p.facing.copy(hit.face.normal); 
                p.visible = true;
            }
        });

        // --- 6. Teleportation Logic ---
        function teleportObject(obj, exitPortal, isPlayer) {
            const entryPortal = (exitPortal === bluePortal) ? orangePortal : bluePortal;
            if (isPlayer) {
                canTeleportPlayer = false;
                setTimeout(() => { canTeleportPlayer = true; }, 100);
            } else {
                obj.canTeleport = false;
                setTimeout(() => { obj.canTeleport = true; }, 100);
            }

            let currentVel = isPlayer 
                ? new THREE.Vector3(velocityXZ.x, velocityY, velocityXZ.z)
                : obj.velocity.clone();

            const entryNormal = entryPortal.facing.clone();
            const exitNormal = exitPortal.facing.clone();
            const quaternion = new THREE.Quaternion().setFromUnitVectors(entryNormal.clone().negate(), exitNormal);
            currentVel.applyQuaternion(quaternion);

            currentVel.multiplyScalar(1.5); // Momentum Boost

            if (isPlayer) {
                velocityXZ.set(currentVel.x, 0, currentVel.z);
                velocityY = currentVel.y;
                camera.position.copy(exitPortal.position).add(exitNormal.clone().multiplyScalar(2.0));
            } else {
                obj.velocity.copy(currentVel);
                obj.position.copy(exitPortal.position).add(exitNormal.clone().multiplyScalar(2.0));
            }
        }

        // --- 7. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (controls.isLocked) {
                velocityY += gravity;
                camera.position.y += velocityY;
                
                if (camera.position.y <= eyeHeight) {
                    const nearBlue = (bluePortal.visible && camera.position.distanceTo(bluePortal.position) < 2.5 && Math.abs(bluePortal.facing.y) > 0.5);
                    const nearOrange = (orangePortal.visible && camera.position.distanceTo(orangePortal.position) < 2.5 && Math.abs(orangePortal.facing.y) > 0.5);
                    if (!nearBlue && !nearOrange) {
                        camera.position.y = eyeHeight;
                        velocityY = Math.max(0, velocityY);
                        if (keys['Space']) velocityY = 0.3;
                    }
                }

                camera.position.add(velocityXZ);
                velocityXZ.multiplyScalar(0.98); 

                const oldPos = camera.position.clone();
                if (keys['KeyW']) controls.moveForward(0.18);
                if (keys['KeyS']) controls.moveForward(-0.18);
                if (keys['KeyA']) controls.moveRight(-0.18);
                if (keys['KeyD']) controls.moveRight(0.18);

                // Player Collision
                for (let wall of walls) {
                    const wallBB = new THREE.Box3().setFromObject(wall);
                    if (wallBB.expandByScalar(0.8).containsPoint(camera.position)) camera.position.copy(oldPos);
                }

                // Puzzle Interaction: Pressure Plate
                let plateActive = false;
                boxes.forEach(box => {
                    if (box.position.distanceTo(plate.position) < 2.5) plateActive = true;
                });

                if (plateActive && !doorOpen) {
                    door.position.y += 15;
                    plate.material.color.set(0x00ff00);
                    walls.splice(walls.indexOf(door), 1); // Disable collision
                    doorOpen = true;
                } else if (!plateActive && doorOpen) {
                    door.position.y -= 15;
                    plate.material.color.set(0xff0000);
                    walls.push(door); // Enable collision
                    doorOpen = false;
                }

                // Box Logic
                boxes.forEach(box => {
                    if (heldBox === box) {
                        const holdPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(holdDistance));
                        box.position.copy(holdPos);
                        box.velocity.set(0, 0, 0);
                    } else {
                        // Gravity & Friction
                        if (box.position.y > 1) {
                            box.velocity.y += gravity;
                        } else {
                            const nearBlue = (bluePortal.visible && box.position.distanceTo(bluePortal.position) < 2 && Math.abs(bluePortal.facing.y) > 0.5);
                            const nearOrange = (orangePortal.visible && box.position.distanceTo(orangePortal.position) < 2 && Math.abs(orangePortal.facing.y) > 0.5);
                            if (!nearBlue && !nearOrange) {
                                box.position.y = 1;
                                box.velocity.y = 0;
                                box.velocity.x *= 0.85; box.velocity.z *= 0.85;
                            }
                        }

                        // PREDICTIVE WALL COLLISION
                        const nextPos = box.position.clone().add(box.velocity);
                        let collided = false;
                        for (let wall of walls) {
                            const wallBB = new THREE.Box3().setFromObject(wall);
                            if (wallBB.expandByScalar(1.0).containsPoint(nextPos)) {
                                box.velocity.multiplyScalar(-0.4); // Bounce
                                collided = true;
                                break;
                            }
                        }
                        if (!collided) box.position.copy(nextPos);
                        box.velocity.multiplyScalar(0.99);

                        // Teleport
                        if (bluePortal.visible && orangePortal.visible && box.canTeleport) {
                            if (box.position.distanceTo(bluePortal.position) < 1.8) teleportObject(box, orangePortal, false);
                            else if (box.position.distanceTo(orangePortal.position) < 1.8) teleportObject(box, bluePortal, false);
                        }
                    }
                });

                // Player Teleport
                if (bluePortal.visible && orangePortal.visible && canTeleportPlayer) {
                    if (camera.position.distanceTo(bluePortal.position) < 2.0) teleportObject(camera, orangePortal, true);
                    else if (camera.position.distanceTo(orangePortal.position) < 2.0) teleportObject(camera, bluePortal, true);
                }
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        camera.position.set(0, eyeHeight, 5);
        animate();
    </script>
</body>
</html>
