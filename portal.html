<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Portal - Fixed Box Collisions</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 14px; height: 14px; border: 2px solid #00ff00;
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
        }
        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: white; background: rgba(0,0,0,0.8); padding: 15px;
            pointer-events: none; border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="instructions">
        <b>Fixed Collision Engine</b><br>
        WASD: Move | SPACE: Jump | E: Grab & Throw<br>
        Click: Fire Portals (Left/Right)
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'this'; // Handled by importmap
        import * as THREE_CORE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const THREE = THREE_CORE;

        // --- Configuration & State ---
        let heldBox = null;
        const holdDistance = 4;
        let lastGrabTime = 0; 
        const boxes = [];
        const walls = [];
        const keys = {};
        
        let velocityY = 0;
        let velocityXZ = new THREE.Vector3();
        const gravity = -0.012; 
        const eyeHeight = 1.6; 
        let canTeleportPlayer = true;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
        scene.add(light);

        const controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener('click', () => controls.lock());

        const loader = new THREE.TextureLoader();
        const wallMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const surfaceMat = new THREE.MeshPhongMaterial({ color: 0x444444 });

        // --- Room Construction ---
        const createWall = (w, h, d, x, y, z) => {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
            m.position.set(x, y, z);
            scene.add(m);
            walls.push(m);
        };

        createWall(60, 100, 5, 0, 50, -32.5); 
        createWall(60, 100, 5, 0, 50, 32.5);  
        createWall(5, 100, 60, 32.5, 50, 0);  
        createWall(5, 100, 60, -32.5, 50, 0);  

        const surfaces = [...walls];
        const floor = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), surfaceMat);
        floor.position.set(0, -1, 0); 
        scene.add(floor);
        surfaces.push(floor);

        // --- Boxes ---
        const boxGeo = new THREE.BoxGeometry(2, 2, 2);
        for(let i = 0; i < 4; i++) {
            const box = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
            box.position.set(Math.random() * 10 - 5, 5, Math.random() * 10 - 5);
            box.velocity = new THREE.Vector3(0, 0, 0);
            box.canTeleport = true; 
            scene.add(box);
            boxes.push(box);
        }

        // --- Portals ---
        const portalGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
        const bluePortal = new THREE.Mesh(portalGeo, new THREE.MeshBasicMaterial({ color: 0x00ccff }));
        const orangePortal = new THREE.Mesh(portalGeo, new THREE.MeshBasicMaterial({ color: 0xff9900 }));
        bluePortal.facing = new THREE.Vector3();
        orangePortal.facing = new THREE.Vector3();
        bluePortal.visible = orangePortal.visible = false;
        scene.add(bluePortal, orangePortal);

        // --- Inputs ---
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE' && performance.now() - lastGrabTime > 250) {
                if (heldBox) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    heldBox.velocity.copy(dir.multiplyScalar(0.8)); // Throw speed
                    heldBox = null;
                } else {
                    let closest = null;
                    let minDist = holdDistance;
                    boxes.forEach(box => {
                        const d = camera.position.distanceTo(box.position);
                        if (d < minDist) { minDist = d; closest = box; }
                    });
                    heldBox = closest;
                }
                lastGrabTime = performance.now();
            }
        });

        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(surfaces);
            if (hits.length > 0) {
                const p = (e.button === 0) ? bluePortal : orangePortal;
                const hit = hits[0];
                p.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.1));
                if (Math.abs(hit.face.normal.y) > 0.5) {
                    p.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), hit.face.normal);
                } else {
                    p.lookAt(hit.point.clone().add(hit.face.normal));
                    p.rotateX(Math.PI/2);
                }
                p.facing.copy(hit.face.normal); 
                p.visible = true;
            }
        });

        // --- Teleportation ---
        function teleportObject(obj, exitPortal, isPlayer) {
            const entryPortal = (exitPortal === bluePortal) ? orangePortal : bluePortal;
            if (isPlayer) {
                canTeleportPlayer = false;
                setTimeout(() => { canTeleportPlayer = true; }, 150);
            } else {
                obj.canTeleport = false;
                setTimeout(() => { obj.canTeleport = true; }, 150);
            }

            let currentVel = isPlayer 
                ? new THREE.Vector3(velocityXZ.x, velocityY, velocityXZ.z)
                : obj.velocity.clone();

            const quaternion = new THREE.Quaternion().setFromUnitVectors(
                entryPortal.facing.clone().negate(), 
                exitPortal.facing
            );
            currentVel.applyQuaternion(quaternion);
            
            // Speed Boost
            currentVel.multiplyScalar(1.5);

            if (isPlayer) {
                velocityXZ.set(currentVel.x, 0, currentVel.z);
                velocityY = currentVel.y;
                camera.position.copy(exitPortal.position).add(exitPortal.facing.clone().multiplyScalar(2.0));
            } else {
                obj.velocity.copy(currentVel);
                obj.position.copy(exitPortal.position).add(exitPortal.facing.clone().multiplyScalar(2.0));
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (controls.isLocked) {
                // Player Physics
                velocityY += gravity;
                camera.position.y += velocityY;
                if (camera.position.y <= eyeHeight) {
                    const nearBlue = (bluePortal.visible && camera.position.distanceTo(bluePortal.position) < 2.5 && Math.abs(bluePortal.facing.y) > 0.5);
                    const nearOrange = (orangePortal.visible && camera.position.distanceTo(orangePortal.position) < 2.5 && Math.abs(orangePortal.facing.y) > 0.5);
                    if (!nearBlue && !nearOrange) {
                        camera.position.y = eyeHeight;
                        velocityY = Math.max(0, velocityY);
                        if (keys['Space']) velocityY = 0.3;
                    }
                }
                camera.position.add(velocityXZ);
                velocityXZ.multiplyScalar(0.98);

                const oldPos = camera.position.clone();
                if (keys['KeyW']) controls.moveForward(0.18);
                if (keys['KeyS']) controls.moveForward(-0.18);
                if (keys['KeyA']) controls.moveRight(-0.18);
                if (keys['KeyD']) controls.moveRight(0.18);

                // Player Wall Collision
                for (let wall of walls) {
                    const wallBB = new THREE.Box3().setFromObject(wall);
                    if (wallBB.expandByScalar(0.8).containsPoint(camera.position)) camera.position.copy(oldPos);
                }

                // BOX LOGIC
                boxes.forEach(box => {
                    if (heldBox === box) {
                        const holdPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(holdDistance));
                        box.position.copy(holdPos);
                        box.velocity.set(0, 0, 0);
                    } else {
                        // Gravity & Floor
                        if (box.position.y > 1) {
                            box.velocity.y += gravity;
                        } else {
                            const nearBlue = (bluePortal.visible && box.position.distanceTo(bluePortal.position) < 2 && Math.abs(bluePortal.facing.y) > 0.5);
                            const nearOrange = (orangePortal.visible && box.position.distanceTo(orangePortal.position) < 2 && Math.abs(orangePortal.facing.y) > 0.5);
                            if (!nearBlue && !nearOrange) {
                                box.position.y = 1;
                                box.velocity.y = 0;
                                box.velocity.x *= 0.8; box.velocity.z *= 0.8;
                            }
                        }

                        // NEW: Box Wall Collision (Prevents throwing through walls)
                        const oldBoxPos = box.position.clone();
                        box.position.add(box.velocity);
                        
                        for (let wall of walls) {
                            const wallBB = new THREE.Box3().setFromObject(wall);
                            // If box enters a wall, bounce it back
                            if (wallBB.expandByScalar(1.1).containsPoint(box.position)) {
                                box.position.copy(oldBoxPos);
                                box.velocity.multiplyScalar(-0.3); // Bounce effect
                            }
                        }

                        box.velocity.multiplyScalar(0.99);

                        // Teleport Check
                        if (bluePortal.visible && orangePortal.visible && box.canTeleport) {
                            if (box.position.distanceTo(bluePortal.position) < 1.8) teleportObject(box, orangePortal, false);
                            else if (box.position.distanceTo(orangePortal.position) < 1.8) teleportObject(box, bluePortal, false);
                        }
                    }
                });

                if (bluePortal.visible && orangePortal.visible && canTeleportPlayer) {
                    if (camera.position.distanceTo(bluePortal.position) < 2.0) teleportObject(camera, orangePortal, true);
                    else if (camera.position.distanceTo(orangePortal.position) < 2.0) teleportObject(camera, bluePortal, true);
                }
            }
            renderer.render(scene, camera);
        }

        camera.position.set(0, eyeHeight, 5);
        animate();
    </script>
</body>
</html>
